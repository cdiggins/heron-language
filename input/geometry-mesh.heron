language heron:std:0.1;

// http://prideout.net/blog/?p=44
// https://github.com/mrdoob/three.js/blob/master/src/geometries/ParametricGeometry.js
// 
module heron:geometry.mesh:0.1
{
    function mesh(vertices) 
        = mesh(vertices, vertices.indices);
    
    var tetrahedron 
        = mesh([1, 1, 1,   -1, -1, 1,   -1, 1, -1,   1, -1, -1], 
	           [2, 1, 0,    0, 3, 2,	1, 3, 0,	 2, 3, 1]);

    // Converts from UV coordinates to a float3
    function vector(uv: Float2)
        = float3(-uv.x.cos * uv.y.sin, uv.x.cos, uv.x.sin * uv.y.sin);
    
    // Works for Float, Float2, Float3, and Float4
    function rescale(v, from, length)
        = from + (v * length);

    function quadStripToMesh(vertices, rows) {
        var cols = vertices.count / 3 / rows;
        var indices = [].mutable;
        for (var r of 0..rows) {
            for (var c of 0..cols) {
                var tri1 = [c + r * cols, c + r * cols + 1, c + (r + 1) * cols];
                var tri2 = [c + (r + 1) * cols + 1), c + (r + 1) * cols, c + (r * cols) + 1];
                indices = indices.push(tri1);
                indices = indices.push(tri2);            
            }
        }
        return mesh(vertices, indices.array);
    }
    
    /* TODO: finish converting this to idiomatic heron.
    function sphere(radius, widthSegments, heightSegment, phiStart, phiLength, thetaStart, thetaLength) {
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        // generate vertices, normals and uvs

        for ( var iy in 0 .. heightSegments ) 
        {
            var verticesRow = [];
            var v = iy / heightSegments;

            for ( var ix in 0 .. widthSegments ) {

                var u = ix / widthSegments;

                // vertex

                var vtx = vector(x, y, z);
                vertices.push(vtx);

                // normal
                var normal = vector(x, y, z).normalize;
                normals.push(normal);

                // uv
                var uv = vector(u, 1 - v, 0);
                uvs.push(uv);
                verticesRow.push( index ++ );
            }

            grid.push( verticesRow );
        }

        // indices
        for ( var iy in 0 .. heightSegments ) {
            for ( var ix in 0 .. widthSegments ) {
                var a = grid[ iy ][ ix + 1 ];
                var b = grid[ iy ][ ix ];
                var c = grid[ iy + 1 ][ ix ];
                var d = grid[ iy + 1 ][ ix + 1 ];
                if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
                if ( iy !== heightSegments - 1 || thetaEnd < PI ) indices.push( b, c, d );
            }        
        }
    }
    */
}   

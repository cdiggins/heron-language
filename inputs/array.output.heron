// Generated on Sun Mar 25 2018 22:31:32 GMT-0400 (Eastern Daylight Time)
heron:std:0.1heron:std.array:0.1{
// definition type undefined

/**
function unit(x) 
        = [x];

    
*/
// definition type undefined
function unit(// definition type 'T0
x)
// expression type undefined
[// expression type 'T0
x]// definition type undefined

/**
function map(xs, f)
        = array(xs.count, i => f(xs[i]));        

    
*/
// definition type undefined
function map(// definition type 'T0
xs, // definition type 'T1
f)
// expression type Error
// expression type Error
array(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type undefined
(// definition type 'T0
i) => // expression type '@1
// expression type 'T1
f(// expression type Error
// expression type undefined
op[](// expression type 'T0
xs, // expression type 'T0
i)))// definition type undefined

/**
function min(x, y) 
        = x <= y ? x : y;

    
*/
// definition type undefined
function min(// definition type 'T0
x, // definition type 'T1
y)
// expression type Error
// expression type Error
// expression type undefined
op<=(// expression type 'T0
x, // expression type 'T1
y) ? // expression type undefined
x// expression type undefined
y// definition type undefined

/**
function max(x, y) 
        = x <= y ? x : y;
   
    
*/
// definition type undefined
function max(// definition type 'T0
x, // definition type 'T1
y)
// expression type Error
// expression type Error
// expression type undefined
op<=(// expression type 'T0
x, // expression type 'T1
y) ? // expression type undefined
x// expression type undefined
y// definition type undefined

/**
function shorter(xs, ys) 
        = xs.count <= ys.count ? xs : ys;
   
    
*/
// definition type undefined
function shorter(// definition type 'T0
xs, // definition type 'T1
ys)
// expression type Error
// expression type Error
// expression type undefined
op<=(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type Error
// expression type Error
count(// expression type 'T1
ys)) ? // expression type undefined
xs// expression type undefined
ys// definition type undefined

/**
function longer(xs, ys) 
        = xs.count >= ys.count ? xs : ys;

    
*/
// definition type undefined
function longer(// definition type 'T0
xs, // definition type 'T1
ys)
// expression type Error
// expression type Error
// expression type undefined
op>=(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type Error
// expression type Error
count(// expression type 'T1
ys)) ? // expression type undefined
xs// expression type undefined
ys// definition type undefined

/**
function empty(xs) 
        = xs.count == 0;

    
*/
// definition type undefined
function empty(// definition type 'T0
xs)
// expression type Error
// expression type undefined
op==(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type Num
0)// definition type undefined

/**
function at(xs, i) 
        = xs[i];

    
*/
// definition type undefined
function at(// definition type 'T0
xs, // definition type 'T1
i)
// expression type Error
// expression type undefined
op[](// expression type 'T0
xs, // expression type 'T1
i)// definition type undefined

/**
function selectByIndex(xs, indices) 
        = indices.map(xs.at);

    
*/
// definition type undefined
function selectByIndex(// definition type 'T0
xs, // definition type 'T1
indices)
// expression type Error
// expression type undefined
map(// expression type 'T1
indices, // expression type Error
// expression type Error
at(// expression type 'T0
xs))// definition type undefined

/**
function indices(xs) 
        = 0 .. xs.count;

    
*/
// definition type undefined
function indices(// definition type 'T0
xs)
// expression type Error
// expression type undefined
op..(// expression type Num
0, // expression type Error
// expression type Error
count(// expression type 'T0
xs))// definition type undefined

/**
function zip(xs, ys, f) 
        = xs.count <= ys.count 
            ? xs.map((x, i) => f(x, ys[i]))
            : ys.map((y, i) => f(xs[i], y));

    
*/
// definition type undefined
function zip(// definition type 'T0
xs, // definition type 'T1
ys, // definition type 'T2
f)
// expression type Error
// expression type Error
// expression type undefined
op<=(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type Error
// expression type Error
count(// expression type 'T1
ys)) ? // expression type undefined
// expression type undefined
map(// expression type undefined
xs, // expression type undefined
(// definition type undefined
x, // definition type undefined
i) => // expression type undefined
// expression type undefined
f(// expression type undefined
x, // expression type undefined
// expression type undefined
op[](// expression type undefined
ys, // expression type undefined
i)))// expression type undefined
// expression type undefined
map(// expression type undefined
ys, // expression type undefined
(// definition type undefined
y, // definition type undefined
i) => // expression type undefined
// expression type undefined
f(// expression type undefined
// expression type undefined
op[](// expression type undefined
xs, // expression type undefined
i), // expression type undefined
y))// definition type undefined

/**
function all(xs, p) 
        = xs.reduce(true, (prev, x) => prev && p(x));    

    
*/
// definition type undefined
function all(// definition type 'T0
xs, // definition type 'T1
p)
// expression type Error
// expression type undefined
reduce(// expression type 'T0
xs, // expression type Bool
true, // expression type undefined
(// definition type 'T0
prev, // definition type 'T1
x) => // expression type Error
// expression type undefined
op&&(// expression type 'T0
prev, // expression type '@2
// expression type 'T1
p(// expression type 'T1
x)))// definition type undefined

/**
function any(xs, p) 
        = xs.reduce(false, (prev, x) => prev || p(x));

    
*/
// definition type undefined
function any(// definition type 'T0
xs, // definition type 'T1
p)
// expression type Error
// expression type undefined
reduce(// expression type 'T0
xs, // expression type Bool
false, // expression type undefined
(// definition type 'T0
prev, // definition type 'T1
x) => // expression type Error
// expression type undefined
op||(// expression type 'T0
prev, // expression type '@3
// expression type 'T1
p(// expression type 'T1
x)))// definition type undefined

/**
function count(xs, p) 
        = xs.reduce(0, (prev, x) => p(x) ? prev + 1 : prev);    

    
*/
// definition type undefined
function count(// definition type 'T0
xs, // definition type 'T1
p)
// expression type Error
// expression type undefined
reduce(// expression type 'T0
xs, // expression type Num
0, // expression type undefined
(// definition type 'T0
prev, // definition type 'T1
x) => // expression type Error
// expression type '@0
// expression type 'T1
p(// expression type 'T1
x) ? // expression type Error
// expression type undefined
op+(// expression type 'T0
prev, // expression type Num
1)// expression type 'T0
prev)// definition type undefined

/**
function eq(xs, ys) 
        = xs.count == ys.count;    

    
*/
// definition type undefined
function eq(// definition type 'T0
xs, // definition type 'T1
ys)
// expression type Error
// expression type undefined
op==(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type Error
// expression type Error
count(// expression type 'T1
ys))// definition type undefined

/**
function filter(xs, p) {
        var ys = xs.mutable;
        var i = 0;
        for (var x in xs) 
            if (p(x)) 
                ys[i++] = x;
        return ys.array.take(i);
    }

    
*/
// definition type undefined
function filter(// definition type 'T0
xs, // definition type 'T1
p)
{
var // definition type Error
ys// expression type Error
// expression type undefined
mutable(// expression type 'T0
xs);
var // definition type Num
i// expression type Num
0;
// definition type '$8
for (x in // expression type 'T0
xs)
{
if (// expression type undefined
// expression type undefined
p(// expression type undefined
x))// expression type undefined
// expression type undefined
ys = // expression type undefined
// expression type undefined
set(// expression type undefined
ys, // expression type undefined
// expression type undefined
i++, // expression type undefined
x);
}
return // expression type Error
// expression type undefined
take(// expression type Error
// expression type Error
array(// expression type Error
ys), // expression type Num
i);
}
// definition type undefined

/**
function repeat(x, n) 
        = (0 .. n).map(i => x);    

    
*/
// definition type undefined
function repeat(// definition type 'T0
x, // definition type 'T1
n)
// expression type Error
// expression type undefined
map(// expression type Error
(// expression type Error
// expression type undefined
op..(// expression type Num
0, // expression type 'T1
n)), // expression type undefined
(// definition type 'T0
i) => // expression type 'T0
x)// definition type undefined

/**
function prefixScan(xs, op) {
        if (xs.empty) return xs;
        var ys = xs[0].repeat(xs.count).mutable;
        for (var i in 1 .. ys.count)
            ys[i] = op(xs[i], ys[i-1]);
        return ys.array;
    }

    
*/
// definition type undefined
function prefixScan(// definition type 'T0
xs, // definition type 'T1
op)
{
{
if (// expression type undefined
// expression type undefined
empty(// expression type undefined
xs))}
{
return // expression type undefined
xs;
}
{
}
var // definition type undefined
ys// expression type undefined
// expression type undefined
mutable(// expression type undefined
// expression type undefined
repeat(// expression type undefined
// expression type undefined
op[](// expression type undefined
xs, // expression type undefined
0), // expression type undefined
// expression type undefined
count(// expression type undefined
xs)));
// definition type undefined
for (i in // expression type undefined
// expression type undefined
op..(// expression type undefined
1, // expression type undefined
// expression type undefined
count(// expression type undefined
ys)))
{
// expression type undefined
// expression type undefined
ys = // expression type undefined
// expression type undefined
set(// expression type undefined
ys, // expression type undefined
i, // expression type undefined
// expression type undefined
op(// expression type undefined
// expression type undefined
op[](// expression type undefined
xs, // expression type undefined
i), // expression type undefined
// expression type undefined
op[](// expression type undefined
ys, // expression type undefined
// expression type undefined
op-(// expression type undefined
i, // expression type undefined
1))));
}
return // expression type undefined
// expression type undefined
array(// expression type undefined
ys);
}
// definition type undefined

/**
function adjacentDifferences(xs) 
        = xs.indices.map(i => i > 0 ? xs[i] - xs[i-1] : xs[i]);
    
    
*/
// definition type undefined
function adjacentDifferences(// definition type 'T0
xs)
// expression type Error
// expression type undefined
map(// expression type Error
// expression type undefined
indices(// expression type 'T0
xs), // expression type undefined
(// definition type 'T0
i) => // expression type Error
// expression type Error
// expression type undefined
op>(// expression type 'T0
i, // expression type Num
0) ? // expression type undefined
// expression type undefined
op-(// expression type undefined
// expression type undefined
op[](// expression type undefined
xs, // expression type undefined
i), // expression type undefined
// expression type undefined
op[](// expression type undefined
xs, // expression type undefined
// expression type undefined
op-(// expression type undefined
i, // expression type undefined
1)))// expression type undefined
// expression type undefined
op[](// expression type undefined
xs, // expression type undefined
i))// definition type undefined

/**
function slice(xs, from, to) 
        = (from .. to).map(xs.at);    

    
*/
// definition type undefined
function slice(// definition type 'T0
xs, // definition type 'T1
from, // definition type 'T2
to)
// expression type Error
// expression type undefined
map(// expression type Error
(// expression type Error
// expression type undefined
op..(// expression type 'T1
from, // expression type 'T2
to)), // expression type Error
// expression type Error
at(// expression type 'T0
xs))// definition type undefined

/**
function stride(xs, n) 
        = (0 .. xs.count / n).map(i => xs[i * n]);    

    
*/
// definition type undefined
function stride(// definition type 'T0
xs, // definition type 'T1
n)
// expression type Error
// expression type undefined
map(// expression type Error
(// expression type Error
// expression type undefined
op..(// expression type Num
0, // expression type Error
// expression type undefined
op/(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type 'T1
n))), // expression type undefined
(// definition type 'T0
i) => // expression type Error
// expression type undefined
op[](// expression type 'T0
xs, // expression type Error
// expression type undefined
op*(// expression type 'T0
i, // expression type 'T1
n)))// definition type undefined

/**
function slices(xs, n) 
        = (0 .. n).map(i => xs.slice(i * n, (i+1) * n));    

    
*/
// definition type undefined
function slices(// definition type 'T0
xs, // definition type 'T1
n)
// expression type Error
// expression type undefined
map(// expression type Error
(// expression type Error
// expression type undefined
op..(// expression type Num
0, // expression type 'T1
n)), // expression type undefined
(// definition type 'T0
i) => // expression type Error
// expression type undefined
slice(// expression type 'T0
xs, // expression type Error
// expression type undefined
op*(// expression type 'T0
i, // expression type 'T1
n), // expression type Error
// expression type undefined
op*(// expression type Error
(// expression type Error
// expression type undefined
op+(// expression type 'T0
i, // expression type Num
1)), // expression type 'T1
n)))// definition type undefined

/**
function take(xs, n) 
        = xs.slice(0, n);    

    
*/
// definition type undefined
function take(// definition type 'T0
xs, // definition type 'T1
n)
// expression type Error
// expression type undefined
slice(// expression type 'T0
xs, // expression type Num
0, // expression type 'T1
n)// definition type undefined

/**
function skip(xs, n) 
        = xs.slice(n, xs.count - n);    

    
*/
// definition type undefined
function skip(// definition type 'T0
xs, // definition type 'T1
n)
// expression type Error
// expression type undefined
slice(// expression type 'T0
xs, // expression type 'T1
n, // expression type Error
// expression type undefined
op-(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type 'T1
n))// definition type undefined

/**
function dropSuffix(xs, n) 
        = xs.take(xs.count - n);    

    
*/
// definition type undefined
function dropSuffix(// definition type 'T0
xs, // definition type 'T1
n)
// expression type Error
// expression type undefined
take(// expression type 'T0
xs, // expression type Error
// expression type undefined
op-(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type 'T1
n))// definition type undefined

/**
function suffix(xs, n) 
        = xs.skip(xs.count-n);

    
*/
// definition type undefined
function suffix(// definition type 'T0
xs, // definition type 'T1
n)
// expression type Error
// expression type undefined
skip(// expression type 'T0
xs, // expression type Error
// expression type undefined
op-(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type 'T1
n))// definition type undefined

/**
function reverse(xs, n) 
        = xs.indices.map(i => xs[xs.count-1-i]);    

    
*/
// definition type undefined
function reverse(// definition type 'T0
xs, // definition type 'T1
n)
// expression type Error
// expression type undefined
map(// expression type Error
// expression type undefined
indices(// expression type 'T0
xs), // expression type undefined
(// definition type 'T0
i) => // expression type Error
// expression type undefined
op[](// expression type 'T0
xs, // expression type Error
// expression type undefined
op-(// expression type Error
// expression type undefined
op-(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type Num
1), // expression type 'T0
i)))// definition type undefined

/**
function gen(cnt, f) 
        = (0 .. cnt).map(f);    

    
*/
// definition type undefined
function gen(// definition type 'T0
cnt, // definition type 'T1
f)
// expression type Error
// expression type undefined
map(// expression type Error
(// expression type Error
// expression type undefined
op..(// expression type Num
0, // expression type 'T0
cnt)), // expression type 'T1
f)// definition type undefined

/**
function concat(xs, ys) 
        = gen(xs.count + ys.count, i => i < xs.count ? xs[i] : ys[i - xs.count]);    

    
*/
// definition type undefined
function concat(// definition type 'T0
xs, // definition type 'T1
ys)
// expression type Error
// expression type undefined
gen(// expression type Error
// expression type undefined
op+(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type Error
// expression type Error
count(// expression type 'T1
ys)), // expression type undefined
(// definition type 'T0
i) => // expression type Error
// expression type Error
// expression type undefined
op<(// expression type 'T0
i, // expression type Error
// expression type Error
count(// expression type 'T0
xs)) ? // expression type undefined
// expression type undefined
op[](// expression type undefined
xs, // expression type undefined
i)// expression type undefined
// expression type undefined
op[](// expression type undefined
ys, // expression type undefined
// expression type undefined
op-(// expression type undefined
i, // expression type undefined
// expression type undefined
count(// expression type undefined
xs))))// definition type undefined

/**
function cut(xs, from, n) 
        = gen(xs.count - n, i => i < from ? xs[i] : xs[i + n]);    

    
*/
// definition type undefined
function cut(// definition type 'T0
xs, // definition type 'T1
from, // definition type 'T2
n)
// expression type Error
// expression type undefined
gen(// expression type Error
// expression type undefined
op-(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type 'T2
n), // expression type undefined
(// definition type 'T0
i) => // expression type Error
// expression type Error
// expression type undefined
op<(// expression type 'T0
i, // expression type 'T1
from) ? // expression type undefined
// expression type undefined
op[](// expression type undefined
xs, // expression type undefined
i)// expression type undefined
// expression type undefined
op[](// expression type undefined
xs, // expression type undefined
// expression type undefined
op+(// expression type undefined
i, // expression type undefined
n)))// definition type undefined

/**
function splice(xs, from, ys) 
        = xs.take(from).concat(ys).concat(xs.skip(from));    

    
*/
// definition type undefined
function splice(// definition type 'T0
xs, // definition type 'T1
from, // definition type 'T2
ys)
// expression type Error
// expression type undefined
concat(// expression type Error
// expression type undefined
concat(// expression type Error
// expression type undefined
take(// expression type 'T0
xs, // expression type 'T1
from), // expression type 'T2
ys), // expression type Error
// expression type undefined
skip(// expression type 'T0
xs, // expression type 'T1
from))// definition type undefined

/**
function sum(xs) 
        = xs.reduce(0, op+);    

    
*/
// definition type undefined
function sum(// definition type 'T0
xs)
// expression type Error
// expression type undefined
reduce(// expression type 'T0
xs, // expression type Num
0, // expression type undefined
op+)// definition type undefined

/**
function product(xs) 
        = xs.reduce(1, op*);    
    
    
*/
// definition type undefined
function product(// definition type 'T0
xs)
// expression type Error
// expression type undefined
reduce(// expression type 'T0
xs, // expression type Num
1, // expression type undefined
op*)// definition type undefined

/**
function average(xs) 
        = xs.sum / xs.count;    

    
*/
// definition type undefined
function average(// definition type 'T0
xs)
// expression type Error
// expression type undefined
op/(// expression type Error
// expression type undefined
sum(// expression type 'T0
xs), // expression type Error
// expression type Error
count(// expression type 'T0
xs))// definition type undefined

/**
function minElement(xs) 
        = xs.reduce(xs[0], min);    

    
*/
// definition type undefined
function minElement(// definition type 'T0
xs)
// expression type Error
// expression type undefined
reduce(// expression type 'T0
xs, // expression type Error
// expression type undefined
op[](// expression type 'T0
xs, // expression type Num
0), // expression type Error
min)// definition type undefined

/**
function maxElement(xs) 
        = xs.reduce(xs[0], max);

    
*/
// definition type undefined
function maxElement(// definition type 'T0
xs)
// expression type Error
// expression type undefined
reduce(// expression type 'T0
xs, // expression type Error
// expression type undefined
op[](// expression type 'T0
xs, // expression type Num
0), // expression type Error
max)// definition type undefined

/**
function partition(a, lo, hi) {
        var pivot = a[lo];
        var i = lo-1;
        var j = hi+1;
        while (true) {
            do { i++; } while (a[i] < pivot);
            do { j--; } while (a[j] > pivot);
            if (i >= j) return j;
            var tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
        return a;
    }

    
*/
// definition type undefined
function partition(// definition type 'T0
a, // definition type 'T1
lo, // definition type 'T2
hi)
{
var // definition type Error
pivot// expression type Error
// expression type undefined
op[](// expression type 'T0
a, // expression type 'T1
lo);
var // definition type Error
i// expression type Error
// expression type undefined
op-(// expression type 'T1
lo, // expression type Num
1);
var // definition type Error
j// expression type Error
// expression type undefined
op+(// expression type 'T2
hi, // expression type Num
1);
while (while (// expression type undefined
true)
)
while (// expression type undefined
true)
{
do
{
// expression type undefined
// expression type undefined
i++;
}
while (// expression type undefined
// expression type undefined
op<(// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
i), // expression type undefined
pivot))
;
do
{
// expression type undefined
// expression type undefined
j--;
}
while (// expression type undefined
// expression type undefined
op>(// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
j), // expression type undefined
pivot))
;
{
if (// expression type undefined
// expression type undefined
op>=(// expression type undefined
i, // expression type undefined
j))}
{
return // expression type undefined
j;
}
{
}
var // definition type undefined
tmp// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
i);
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
set(// expression type undefined
a, // expression type undefined
i, // expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
j));
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
set(// expression type undefined
a, // expression type undefined
j, // expression type undefined
tmp);
}
{
do
{
// expression type undefined
// expression type undefined
i++;
}
while (// expression type undefined
// expression type undefined
op<(// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
i), // expression type undefined
pivot))
;
do
{
// expression type undefined
// expression type undefined
j--;
}
while (// expression type undefined
// expression type undefined
op>(// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
j), // expression type undefined
pivot))
;
{
if (// expression type undefined
// expression type undefined
op>=(// expression type undefined
i, // expression type undefined
j))}
{
return // expression type undefined
j;
}
{
}
var // definition type undefined
tmp// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
i);
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
set(// expression type undefined
a, // expression type undefined
i, // expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
j));
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
set(// expression type undefined
a, // expression type undefined
j, // expression type undefined
tmp);
}
return // expression type 'T0
a;
}
// definition type undefined

/**
function qsort(a, lo, hi) {
        if (lo < hi) {
            var p = a[lo]; 
            a = partition(a, lo, hi);
            a = qsort(a, lo, p);
            a = qsort(a, p+1, hi);
        }
        return a;
    }

    
*/
// definition type undefined
function qsort(// definition type 'T0
a, // definition type 'T1
lo, // definition type 'T2
hi)
{
{
if (// expression type undefined
// expression type undefined
op<(// expression type undefined
lo, // expression type undefined
hi))}
{
var // definition type undefined
p// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
lo);
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
partition(// expression type undefined
a, // expression type undefined
lo, // expression type undefined
hi);
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
qsort(// expression type undefined
a, // expression type undefined
lo, // expression type undefined
p);
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
qsort(// expression type undefined
a, // expression type undefined
// expression type undefined
op+(// expression type undefined
p, // expression type undefined
1), // expression type undefined
hi);
}
{
}
return // expression type undefined
a;
}
// definition type undefined

/**
function sort(xs) 
        = xs.mutable.qsort(0, xs.count-1).array;    

    
*/
// definition type undefined
function sort(// definition type 'T0
xs)
// expression type Error
// expression type Error
array(// expression type Error
// expression type undefined
qsort(// expression type Error
// expression type undefined
mutable(// expression type 'T0
xs), // expression type Num
0, // expression type Error
// expression type undefined
op-(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type Num
1)))// definition type undefined

/**
function median(xs) {        
        var ys = xs.sort;
        return ys.count % 2 == 0 
            ? ys[ys.count / 2] 
            : ys[ys.count / 2 - 1] + ys[ys.count / 2 + 1] / 2;
    }

    
*/
// definition type undefined
function median(// definition type 'T0
xs)
{
var // definition type Error
ys// expression type Error
// expression type undefined
sort(// expression type 'T0
xs);
return // expression type Error
// expression type Error
// expression type undefined
op==(// expression type Error
// expression type undefined
op%(// expression type Error
// expression type Error
count(// expression type Error
ys), // expression type Num
2), // expression type Num
0) ? // expression type undefined
// expression type undefined
op[](// expression type undefined
ys, // expression type undefined
// expression type undefined
op/(// expression type undefined
// expression type undefined
count(// expression type undefined
ys), // expression type undefined
2))// expression type undefined
// expression type undefined
op+(// expression type undefined
// expression type undefined
op[](// expression type undefined
ys, // expression type undefined
// expression type undefined
op-(// expression type undefined
// expression type undefined
op/(// expression type undefined
// expression type undefined
count(// expression type undefined
ys), // expression type undefined
2), // expression type undefined
1)), // expression type undefined
// expression type undefined
op/(// expression type undefined
// expression type undefined
op[](// expression type undefined
ys, // expression type undefined
// expression type undefined
op+(// expression type undefined
// expression type undefined
op/(// expression type undefined
// expression type undefined
count(// expression type undefined
ys), // expression type undefined
2), // expression type undefined
1)), // expression type undefined
2));
}
// definition type undefined

/**
function inRange(xs, n) 
        = n >= 0 && n < xs.count;    

    
*/
// definition type undefined
function inRange(// definition type 'T0
xs, // definition type 'T1
n)
// expression type Error
// expression type undefined
op&&(// expression type Error
// expression type undefined
op>=(// expression type 'T1
n, // expression type Num
0), // expression type Error
// expression type undefined
op<(// expression type 'T1
n, // expression type Error
// expression type Error
count(// expression type 'T0
xs)))// definition type undefined

/**
function last(xs) 
        = xs[xs.count - 1];    

    
*/
// definition type undefined
function last(// definition type 'T0
xs)
// expression type Error
// expression type undefined
op[](// expression type 'T0
xs, // expression type Error
// expression type undefined
op-(// expression type Error
// expression type Error
count(// expression type 'T0
xs), // expression type Num
1))// definition type undefined

/**
function first(xs) 
        = xs[0];

    
*/
// definition type undefined
function first(// definition type 'T0
xs)
// expression type Error
// expression type undefined
op[](// expression type 'T0
xs, // expression type Num
0)// definition type undefined

/**
function reduce(xs, acc, f) {
        for (var x in xs)
            acc = f(acc, x);
        return acc;
    }

    
*/
// definition type undefined
function reduce(// definition type 'T0
xs, // definition type 'T1
acc, // definition type 'T2
f)
{
// definition type '$3
for (x in // expression type 'T0
xs)
{
// expression type undefined
// expression type undefined
acc = // expression type undefined
// expression type undefined
f(// expression type undefined
acc, // expression type undefined
x);
}
return // expression type 'T1
acc;
}
// definition type undefined

/**
function flatten(xs)
        = xs.reduce([], concat);

    
*/
// definition type undefined
function flatten(// definition type 'T0
xs)
// expression type Error
// expression type undefined
reduce(// expression type 'T0
xs, // expression type undefined
[], // expression type undefined
concat)// definition type undefined

/**
function flatMap(xs, f)       
        = xs.map(f).flatten;

*/
// definition type undefined
function flatMap(// definition type 'T0
xs, // definition type 'T1
f)
// expression type Error
// expression type undefined
flatten(// expression type Error
// expression type undefined
map(// expression type 'T0
xs, // expression type 'T1
f))}

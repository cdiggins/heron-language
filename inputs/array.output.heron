// Generated on Sat Mar 24 2018 16:42:23 GMT-0400 (Eastern Daylight Time)
heron:std:0.1heron:std.array:0.1{
// definition type (Func T0 R)

/**
function unit(x) 
        = [x];

    
*/
// definition type (Func T0 R)
function unit(// definition type T0
x)
// expression type (Array T0)
[// expression type T0
x]// definition type (Func T0 T1 R)

/**
function map(xs, f)
        = array(xs.count, i => f(xs[i]));        

    
*/
// definition type (Func T0 T1 R)
function map(// definition type T0
xs, // definition type T1
f)
// expression type Error
// expression type (FuncSet ((Func Int (Func Int T) (Array T)) (Func (ArrayBuilder T) (Array T)) (Func Float2 R) (Func Float3 R) (Func Float4 R)))
array(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type (Func T0 R)
(// definition type T0
i) => // expression type $21
// expression type T1
f(// expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type T0
i)))// definition type !R!T0.(Func T0 T0 R)

/**
function min(x, y) 
        = x <= y ? x : y;

    
*/
// definition type !R!T0.(Func T0 T0 R)
function min(// definition type T0
x, // definition type T1
y)
// expression type T0
// expression type Error
// expression type (Func Float Float Bool)
op<=(// expression type T0
x, // expression type T1
y) ? // expression type T0
x// expression type T1
y// definition type !R!T0.(Func T0 T0 R)

/**
function max(x, y) 
        = x <= y ? x : y;
   
    
*/
// definition type !R!T0.(Func T0 T0 R)
function max(// definition type T0
x, // definition type T1
y)
// expression type T0
// expression type Error
// expression type (Func Float Float Bool)
op<=(// expression type T0
x, // expression type T1
y) ? // expression type T0
x// expression type T1
y// definition type (Func T0 T0 R)

/**
function shorter(xs, ys) 
        = xs.count <= ys.count ? xs : ys;
   
    
*/
// definition type (Func T0 T0 R)
function shorter(// definition type T0
xs, // definition type T1
ys)
// expression type T0
// expression type Error
// expression type (Func Float Float Bool)
op<=(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T1
ys)) ? // expression type T0
xs// expression type T1
ys// definition type (Func T0 T0 R)

/**
function longer(xs, ys) 
        = xs.count >= ys.count ? xs : ys;

    
*/
// definition type (Func T0 T0 R)
function longer(// definition type T0
xs, // definition type T1
ys)
// expression type T0
// expression type Error
// expression type (Func Float Float Bool)
op>=(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T1
ys)) ? // expression type T0
xs// expression type T1
ys// definition type (Func T0 R)

/**
function empty(xs) 
        = xs.count == 0;

    
*/
// definition type (Func T0 R)
function empty(// definition type T0
xs)
// expression type Error
// expression type (Func Float Float Bool)
op==(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type Num
0)// definition type !R!T0!T1.(Func T0 T1 R)

/**
function at(xs, i) 
        = xs[i];

    
*/
// definition type !R!T0!T1.(Func T0 T1 R)
function at(// definition type T0
xs, // definition type T1
i)
// expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type T1
i)// definition type (Func T0 T1 R)

/**
function selectByIndex(xs, indices) 
        = indices.map(xs.at);

    
*/
// definition type (Func T0 T1 R)
function selectByIndex(// definition type T0
xs, // definition type T1
indices)
// expression type Error
// expression type (Func T0 T1 R)
map(// expression type T1
indices, // expression type Error
// expression type (FuncSet ((Func (Array T) Int T) (Func (ArrayBuilder T) Int T) (Func T0 T1 R)))
at(// expression type T0
xs))// definition type (Func T0 R)

/**
function indices(xs) 
        = 0 .. xs.count;

    
*/
// definition type (Func T0 R)
function indices(// definition type T0
xs)
// expression type Error
// expression type (Func Int Int (Array Int))
op..(// expression type Num
0, // expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs))// definition type (Func T0 T1 T2 R)

/**
function zip(xs, ys, f) 
        = xs.count <= ys.count 
            ? xs.map((x, i) => f(x, ys[i]))
            : ys.map((y, i) => f(xs[i], y));

    
*/
// definition type (Func T0 T1 T2 R)
function zip(// definition type T0
xs, // definition type T1
ys, // definition type T2
f)
// expression type Error
// expression type Error
// expression type (Func Float Float Bool)
op<=(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T1
ys)) ? // expression type Error
// expression type (Func T0 T1 R)
map(// expression type T0
xs, // expression type (Func T0 T1 R)
(// definition type T0
x, // definition type T1
i) => // expression type $998
// expression type T2
f(// expression type T0
x, // expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T1
ys, // expression type T1
i)))// expression type Error
// expression type (Func T0 T1 R)
map(// expression type T1
ys, // expression type (Func T0 T1 R)
(// definition type T0
y, // definition type T1
i) => // expression type $1006
// expression type T2
f(// expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type T1
i), // expression type T0
y))// definition type (Func T0 T1 R)

/**
function all(xs, p) 
        = xs.reduce(true, (prev, x) => prev && p(x));    

    
*/
// definition type (Func T0 T1 R)
function all(// definition type T0
xs, // definition type T1
p)
// expression type Error
// expression type (Func (Array $4) T1 T2 T1)
reduce(// expression type T0
xs, // expression type Bool
true, // expression type (Func T0 (Func (rec 0) $36) R)
(// definition type T0
prev, // definition type T1
x) => // expression type Error
// expression type (Func Bool Bool Bool)
op&&(// expression type T0
prev, // expression type $36
// expression type T1
p(// expression type T1
x)))// definition type (Func T0 T1 R)

/**
function any(xs, p) 
        = xs.reduce(false, (prev, x) => prev || p(x));

    
*/
// definition type (Func T0 T1 R)
function any(// definition type T0
xs, // definition type T1
p)
// expression type Error
// expression type (Func (Array $4) T1 T2 T1)
reduce(// expression type T0
xs, // expression type Bool
false, // expression type (Func T0 (Func (rec 0) $43) R)
(// definition type T0
prev, // definition type T1
x) => // expression type Error
// expression type (Func Bool Bool Bool)
op||(// expression type T0
prev, // expression type $43
// expression type T1
p(// expression type T1
x)))// definition type !R!T0!T1.(Func T0 T1 R)

/**
function count(xs, p) 
        = xs.reduce(0, (prev, x) => p(x) ? prev + 1 : prev);    

    
*/
// definition type !R!T0!T1.(Func T0 T1 R)
function count(// definition type T0
xs, // definition type T1
p)
// expression type Error
// expression type (Func (Array $4) T1 T2 T1)
reduce(// expression type T0
xs, // expression type Num
0, // expression type (Func Error (Func (rec 0) Bool) R)
(// definition type T0
prev, // definition type T1
x) => // expression type Error
// expression type $11
// expression type T1
p(// expression type T1
x) ? // expression type Error
// expression type (Func Float Float Float)
op+(// expression type T0
prev, // expression type Num
1)// expression type T0
prev)// definition type (Func T0 T1 R)

/**
function eq(xs, ys) 
        = xs.count == ys.count;    

    
*/
// definition type (Func T0 T1 R)
function eq(// definition type T0
xs, // definition type T1
ys)
// expression type Error
// expression type (Func Float Float Bool)
op==(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T1
ys))// definition type (Func (Array $1504) T1 Error)

/**
function filter(xs, p) {
        var ys = xs.mutable;
        var i = 0;
        for (var x in xs) 
            if (p(x)) 
                ys[i++] = x;
        return ys.array.take(i);
    }

    
*/
// definition type (Func (Array $1504) T1 Error)
function filter(// definition type T0
xs, // definition type T1
p)
{
var // definition type Error
ys// expression type Error
// expression type (Func (Array T) (ArrayBuilder T))
mutable(// expression type T0
xs);
var // definition type Num
i// expression type Num
0;
// definition type $1504
for (x in // expression type T0
xs)
{
if (// expression type undefined
// expression type undefined
p(// expression type undefined
x))// expression type undefined
// expression type undefined
ys = // expression type undefined
// expression type undefined
set(// expression type undefined
ys, // expression type undefined
// expression type undefined
i++, // expression type undefined
x);
}
return // expression type Error
// expression type (Func (Array $1504) T1 R)
take(// expression type (union ((Array T) R))
// expression type (FuncSet ((Func Int (Func Int T) (Array T)) (Func (ArrayBuilder T) !T.(Array T)) (Func Float2 R) (Func Float3 R) (Func Float4 R)))
array(// expression type Error
ys), // expression type Num
i);
}
// definition type (Func T0 T1 R)

/**
function repeat(x, n) 
        = (0 .. n).map(i => x);    

    
*/
// definition type (Func T0 T1 R)
function repeat(// definition type T0
x, // definition type T1
n)
// expression type Error
// expression type (Func T0 T1 R)
map(// expression type Error
(// expression type Error
// expression type (Func Int Int (Array Int))
op..(// expression type Num
0, // expression type T1
n)), // expression type (Func T0 R)
(// definition type T0
i) => // expression type T0
x)// definition type (Func T0 T1 R)

/**
function prefixScan(xs, op) {
        if (xs.empty) return xs;
        var ys = xs[0].repeat(xs.count).mutable;
        for (var i in 1 .. ys.count)
            ys[i] = op(xs[i], ys[i-1]);
        return ys.array;
    }

    
*/
// definition type (Func T0 T1 R)
function prefixScan(// definition type T0
xs, // definition type T1
op)
{
{
if (// expression type undefined
// expression type undefined
empty(// expression type undefined
xs))}
{
return // expression type undefined
xs;
}
{
}
var // definition type undefined
ys// expression type undefined
// expression type undefined
mutable(// expression type undefined
// expression type undefined
repeat(// expression type undefined
// expression type undefined
op[](// expression type undefined
xs, // expression type undefined
0), // expression type undefined
// expression type undefined
count(// expression type undefined
xs)));
// definition type undefined
for (i in // expression type undefined
// expression type undefined
op..(// expression type undefined
1, // expression type undefined
// expression type undefined
count(// expression type undefined
ys)))
{
// expression type undefined
// expression type undefined
ys = // expression type undefined
// expression type undefined
set(// expression type undefined
ys, // expression type undefined
i, // expression type undefined
// expression type undefined
op(// expression type undefined
// expression type undefined
op[](// expression type undefined
xs, // expression type undefined
i), // expression type undefined
// expression type undefined
op[](// expression type undefined
ys, // expression type undefined
// expression type undefined
op-(// expression type undefined
i, // expression type undefined
1))));
}
return // expression type undefined
// expression type undefined
array(// expression type undefined
ys);
}
// definition type (Func T0 R)

/**
function adjacentDifferences(xs) 
        = xs.indices.map(i => i > 0 ? xs[i] - xs[i-1] : xs[i]);
    
    
*/
// definition type (Func T0 R)
function adjacentDifferences(// definition type T0
xs)
// expression type Error
// expression type (Func T0 T1 R)
map(// expression type Error
// expression type (Func T0 R)
indices(// expression type T0
xs), // expression type (Func T0 R)
(// definition type T0
i) => // expression type Error
// expression type Error
// expression type (Func Float Float Bool)
op>(// expression type T0
i, // expression type Num
0) ? // expression type Error
// expression type (Func Float Float Float)
op-(// expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type T0
i), // expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type Error
// expression type (Func Float Float Float)
op-(// expression type T0
i, // expression type Num
1)))// expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type T0
i))// definition type (Func T0 T1 T2 R)

/**
function slice(xs, from, to) 
        = (from .. to).map(xs.at);    

    
*/
// definition type (Func T0 T1 T2 R)
function slice(// definition type T0
xs, // definition type T1
from, // definition type T2
to)
// expression type Error
// expression type (Func T0 T1 R)
map(// expression type Error
(// expression type Error
// expression type (Func Int Int (Array Int))
op..(// expression type T1
from, // expression type T2
to)), // expression type Error
// expression type (FuncSet ((Func (Array T) Int T) (Func (ArrayBuilder T) Int T) (Func T0 T1 R)))
at(// expression type T0
xs))// definition type (Func T0 T1 R)

/**
function stride(xs, n) 
        = (0 .. xs.count / n).map(i => xs[i * n]);    

    
*/
// definition type (Func T0 T1 R)
function stride(// definition type T0
xs, // definition type T1
n)
// expression type Error
// expression type (Func T0 T1 R)
map(// expression type Error
(// expression type Error
// expression type (Func Int Int (Array Int))
op..(// expression type Num
0, // expression type Error
// expression type (Func Float Float Float)
op/(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type T1
n))), // expression type (Func T0 R)
(// definition type T0
i) => // expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type Error
// expression type (Func Float Float Float)
op*(// expression type T0
i, // expression type T1
n)))// definition type (Func T0 T1 R)

/**
function slices(xs, n) 
        = (0 .. n).map(i => xs.slice(i * n, (i+1) * n));    

    
*/
// definition type (Func T0 T1 R)
function slices(// definition type T0
xs, // definition type T1
n)
// expression type Error
// expression type (Func T0 T1 R)
map(// expression type Error
(// expression type Error
// expression type (Func Int Int (Array Int))
op..(// expression type Num
0, // expression type T1
n)), // expression type (Func T0 R)
(// definition type T0
i) => // expression type Error
// expression type (Func T0 T1 T2 R)
slice(// expression type T0
xs, // expression type Error
// expression type (Func Float Float Float)
op*(// expression type T0
i, // expression type T1
n), // expression type Error
// expression type (Func Float Float Float)
op*(// expression type Error
(// expression type Error
// expression type (Func Float Float Float)
op+(// expression type T0
i, // expression type Num
1)), // expression type T1
n)))// definition type (Func T0 T1 R)

/**
function take(xs, n) 
        = xs.slice(0, n);    

    
*/
// definition type (Func T0 T1 R)
function take(// definition type T0
xs, // definition type T1
n)
// expression type Error
// expression type (Func T0 T1 T2 R)
slice(// expression type T0
xs, // expression type Num
0, // expression type T1
n)// definition type (Func T0 T1 R)

/**
function skip(xs, n) 
        = xs.slice(n, xs.count - n);    

    
*/
// definition type (Func T0 T1 R)
function skip(// definition type T0
xs, // definition type T1
n)
// expression type Error
// expression type (Func T0 T1 T2 R)
slice(// expression type T0
xs, // expression type T1
n, // expression type Error
// expression type (Func Float Float Float)
op-(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type T1
n))// definition type (Func T0 T1 R)

/**
function dropSuffix(xs, n) 
        = xs.take(xs.count - n);    

    
*/
// definition type (Func T0 T1 R)
function dropSuffix(// definition type T0
xs, // definition type T1
n)
// expression type Error
// expression type (Func T0 T1 R)
take(// expression type T0
xs, // expression type Error
// expression type (Func Float Float Float)
op-(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type T1
n))// definition type (Func T0 T1 R)

/**
function suffix(xs, n) 
        = xs.skip(xs.count-n);

    
*/
// definition type (Func T0 T1 R)
function suffix(// definition type T0
xs, // definition type T1
n)
// expression type Error
// expression type (Func T0 T1 R)
skip(// expression type T0
xs, // expression type Error
// expression type (Func Float Float Float)
op-(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type T1
n))// definition type (Func T0 T1 R)

/**
function reverse(xs, n) 
        = xs.indices.map(i => xs[xs.count-1-i]);    

    
*/
// definition type (Func T0 T1 R)
function reverse(// definition type T0
xs, // definition type T1
n)
// expression type Error
// expression type (Func T0 T1 R)
map(// expression type Error
// expression type (Func T0 R)
indices(// expression type T0
xs), // expression type (Func T0 R)
(// definition type T0
i) => // expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type Error
// expression type (Func Float Float Float)
op-(// expression type Error
// expression type (Func Float Float Float)
op-(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type Num
1), // expression type T0
i)))// definition type (Func T0 T1 R)

/**
function gen(cnt, f) 
        = (0 .. cnt).map(f);    

    
*/
// definition type (Func T0 T1 R)
function gen(// definition type T0
cnt, // definition type T1
f)
// expression type Error
// expression type (Func T0 T1 R)
map(// expression type Error
(// expression type Error
// expression type (Func Int Int (Array Int))
op..(// expression type Num
0, // expression type T0
cnt)), // expression type T1
f)// definition type (Func T0 T1 R)

/**
function concat(xs, ys) 
        = gen(xs.count + ys.count, i => i < xs.count ? xs[i] : ys[i - xs.count]);    

    
*/
// definition type (Func T0 T1 R)
function concat(// definition type T0
xs, // definition type T1
ys)
// expression type Error
// expression type (Func T0 T1 R)
gen(// expression type Error
// expression type (Func Float Float Float)
op+(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T1
ys)), // expression type (Func T0 R)
(// definition type T0
i) => // expression type Error
// expression type Error
// expression type (Func Float Float Bool)
op<(// expression type T0
i, // expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs)) ? // expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type T0
i)// expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T1
ys, // expression type Error
// expression type (Func Float Float Float)
op-(// expression type T0
i, // expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs))))// definition type (Func T0 T1 T2 R)

/**
function cut(xs, from, n) 
        = gen(xs.count - n, i => i < from ? xs[i] : xs[i + n]);    

    
*/
// definition type (Func T0 T1 T2 R)
function cut(// definition type T0
xs, // definition type T1
from, // definition type T2
n)
// expression type Error
// expression type (Func T0 T1 R)
gen(// expression type Error
// expression type (Func Float Float Float)
op-(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type T2
n), // expression type (Func T0 R)
(// definition type T0
i) => // expression type Error
// expression type Error
// expression type (Func Float Float Bool)
op<(// expression type T0
i, // expression type T1
from) ? // expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type T0
i)// expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type Error
// expression type (Func Float Float Float)
op+(// expression type T0
i, // expression type T2
n)))// definition type (Func T0 T1 T2 R)

/**
function splice(xs, from, ys) 
        = xs.take(from).concat(ys).concat(xs.skip(from));    

    
*/
// definition type (Func T0 T1 T2 R)
function splice(// definition type T0
xs, // definition type T1
from, // definition type T2
ys)
// expression type Error
// expression type (Func T0 T1 R)
concat(// expression type Error
// expression type (Func T0 T1 R)
concat(// expression type Error
// expression type (Func T0 T1 R)
take(// expression type T0
xs, // expression type T1
from), // expression type T2
ys), // expression type Error
// expression type (Func T0 T1 R)
skip(// expression type T0
xs, // expression type T1
from))// definition type (Func T0 R)

/**
function sum(xs) 
        = xs.reduce(0, op+);    

    
*/
// definition type (Func T0 R)
function sum(// definition type T0
xs)
// expression type Error
// expression type (Func (Array $4) T1 T2 T1)
reduce(// expression type T0
xs, // expression type Num
0, // expression type (Func Float Float Float)
op+)// definition type (Func T0 R)

/**
function product(xs) 
        = xs.reduce(1, op*);    
    
    
*/
// definition type (Func T0 R)
function product(// definition type T0
xs)
// expression type Error
// expression type (Func (Array $4) T1 T2 T1)
reduce(// expression type T0
xs, // expression type Num
1, // expression type (Func Float Float Float)
op*)// definition type (Func T0 R)

/**
function average(xs) 
        = xs.sum / xs.count;    

    
*/
// definition type (Func T0 R)
function average(// definition type T0
xs)
// expression type Error
// expression type (Func Float Float Float)
op/(// expression type Error
// expression type (Func T0 R)
sum(// expression type T0
xs), // expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs))// definition type (Func T0 R)

/**
function minElement(xs) 
        = xs.reduce(xs[0], min);    

    
*/
// definition type (Func T0 R)
function minElement(// definition type T0
xs)
// expression type Error
// expression type (Func (Array $4) T1 T2 T1)
reduce(// expression type T0
xs, // expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type Num
0), // expression type (FuncSet ((Func Float Float Float) (Func T0 T0 R)))
min)// definition type (Func T0 R)

/**
function maxElement(xs) 
        = xs.reduce(xs[0], max);

    
*/
// definition type (Func T0 R)
function maxElement(// definition type T0
xs)
// expression type Error
// expression type (Func (Array $4) T1 T2 T1)
reduce(// expression type T0
xs, // expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type Num
0), // expression type (FuncSet ((Func Float Float Float) (Func T0 T0 R)))
max)// definition type (Func T0 T1 T2 T0)

/**
function partition(a, lo, hi) {
        var pivot = a[lo];
        var i = lo-1;
        var j = hi+1;
        while (true) {
            do { i++; } while (a[i] < pivot);
            do { j--; } while (a[j] > pivot);
            if (i >= j) return j;
            var tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
        return a;
    }

    
*/
// definition type (Func T0 T1 T2 T0)
function partition(// definition type T0
a, // definition type T1
lo, // definition type T2
hi)
{
var // definition type Error
pivot// expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
a, // expression type T1
lo);
var // definition type Error
i// expression type Error
// expression type (Func Float Float Float)
op-(// expression type T1
lo, // expression type Num
1);
var // definition type Error
j// expression type Error
// expression type (Func Float Float Float)
op+(// expression type T2
hi, // expression type Num
1);
while (while (// expression type undefined
true)
)
while (// expression type undefined
true)
{
do
{
// expression type undefined
// expression type undefined
i++;
}
while (// expression type undefined
// expression type undefined
op<(// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
i), // expression type undefined
pivot))
;
do
{
// expression type undefined
// expression type undefined
j--;
}
while (// expression type undefined
// expression type undefined
op>(// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
j), // expression type undefined
pivot))
;
{
if (// expression type undefined
// expression type undefined
op>=(// expression type undefined
i, // expression type undefined
j))}
{
return // expression type undefined
j;
}
{
}
var // definition type undefined
tmp// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
i);
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
set(// expression type undefined
a, // expression type undefined
i, // expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
j));
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
set(// expression type undefined
a, // expression type undefined
j, // expression type undefined
tmp);
}
{
do
{
// expression type undefined
// expression type undefined
i++;
}
while (// expression type undefined
// expression type undefined
op<(// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
i), // expression type undefined
pivot))
;
do
{
// expression type undefined
// expression type undefined
j--;
}
while (// expression type undefined
// expression type undefined
op>(// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
j), // expression type undefined
pivot))
;
{
if (// expression type undefined
// expression type undefined
op>=(// expression type undefined
i, // expression type undefined
j))}
{
return // expression type undefined
j;
}
{
}
var // definition type undefined
tmp// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
i);
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
set(// expression type undefined
a, // expression type undefined
i, // expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
j));
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
set(// expression type undefined
a, // expression type undefined
j, // expression type undefined
tmp);
}
return // expression type T0
a;
}
// definition type (Func T0 T1 T2 R)

/**
function qsort(a, lo, hi) {
        if (lo < hi) {
            var p = a[lo]; 
            a = partition(a, lo, hi);
            a = qsort(a, lo, p);
            a = qsort(a, p+1, hi);
        }
        return a;
    }

    
*/
// definition type (Func T0 T1 T2 R)
function qsort(// definition type T0
a, // definition type T1
lo, // definition type T2
hi)
{
{
if (// expression type undefined
// expression type undefined
op<(// expression type undefined
lo, // expression type undefined
hi))}
{
var // definition type undefined
p// expression type undefined
// expression type undefined
op[](// expression type undefined
a, // expression type undefined
lo);
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
partition(// expression type undefined
a, // expression type undefined
lo, // expression type undefined
hi);
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
qsort(// expression type undefined
a, // expression type undefined
lo, // expression type undefined
p);
// expression type undefined
// expression type undefined
a = // expression type undefined
// expression type undefined
qsort(// expression type undefined
a, // expression type undefined
// expression type undefined
op+(// expression type undefined
p, // expression type undefined
1), // expression type undefined
hi);
}
{
}
return // expression type undefined
a;
}
// definition type (Func T0 R)

/**
function sort(xs) 
        = xs.mutable.qsort(0, xs.count-1).array;    

    
*/
// definition type (Func T0 R)
function sort(// definition type T0
xs)
// expression type (union ((Array T) R))
// expression type (FuncSet ((Func Int (Func Int T) (Array T)) (Func (ArrayBuilder T) !T.(Array T)) (Func Float2 R) (Func Float3 R) (Func Float4 R)))
array(// expression type Error
// expression type (Func T0 T1 T2 R)
qsort(// expression type Error
// expression type (Func (Array T) (ArrayBuilder T))
mutable(// expression type T0
xs), // expression type Num
0, // expression type Error
// expression type (Func Float Float Float)
op-(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type Num
1)))// definition type (Func T0 Error)

/**
function median(xs) {        
        var ys = xs.sort;
        return ys.count % 2 == 0 
            ? ys[ys.count / 2] 
            : ys[ys.count / 2 - 1] + ys[ys.count / 2 + 1] / 2;
    }

    
*/
// definition type (Func T0 Error)
function median(// definition type T0
xs)
{
var // definition type Error
ys// expression type Error
// expression type (Func T0 R)
sort(// expression type T0
xs);
return // expression type Error
// expression type Error
// expression type (Func Float Float Bool)
op==(// expression type Error
// expression type (Func Float Float Float)
op%(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type Error
ys), // expression type Num
2), // expression type Num
0) ? // expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type Error
ys, // expression type Error
// expression type (Func Float Float Float)
op/(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type Error
ys), // expression type Num
2))// expression type Error
// expression type (Func Float Float Float)
op+(// expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type Error
ys, // expression type Error
// expression type (Func Float Float Float)
op-(// expression type Error
// expression type (Func Float Float Float)
op/(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type Error
ys), // expression type Num
2), // expression type Num
1)), // expression type Error
// expression type (Func Float Float Float)
op/(// expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type Error
ys, // expression type Error
// expression type (Func Float Float Float)
op+(// expression type Error
// expression type (Func Float Float Float)
op/(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type Error
ys), // expression type Num
2), // expression type Num
1)), // expression type Num
2));
}
// definition type (Func T0 T1 R)

/**
function inRange(xs, n) 
        = n >= 0 && n < xs.count;    

    
*/
// definition type (Func T0 T1 R)
function inRange(// definition type T0
xs, // definition type T1
n)
// expression type Error
// expression type (Func Bool Bool Bool)
op&&(// expression type Error
// expression type (Func Float Float Bool)
op>=(// expression type T1
n, // expression type Num
0), // expression type Error
// expression type (Func Float Float Bool)
op<(// expression type T1
n, // expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs)))// definition type (Func T0 R)

/**
function last(xs) 
        = xs[xs.count - 1];    

    
*/
// definition type (Func T0 R)
function last(// definition type T0
xs)
// expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type Error
// expression type (Func Float Float Float)
op-(// expression type Int
// expression type (FuncSet ((Func (Array T) Int) (Func (ArrayBuilder T) Int) (Func T0 T1 R)))
count(// expression type T0
xs), // expression type Num
1))// definition type (Func T0 R)

/**
function first(xs) 
        = xs[0];

    
*/
// definition type (Func T0 R)
function first(// definition type T0
xs)
// expression type Error
// expression type (Func (Array T) Int T)
op[](// expression type T0
xs, // expression type Num
0)// definition type (Func (Array $4) T1 T2 T1)

/**
function reduce(xs, acc, f) {
        for (var x in xs)
            acc = f(acc, x);
        return acc;
    }

    
*/
// definition type (Func (Array $4) T1 T2 T1)
function reduce(// definition type T0
xs, // definition type T1
acc, // definition type T2
f)
{
// definition type $4
for (x in // expression type T0
xs)
{
// expression type undefined
// expression type undefined
acc = // expression type undefined
// expression type undefined
f(// expression type undefined
acc, // expression type undefined
x);
}
return // expression type T1
acc;
}
// definition type (Func T0 R)

/**
function flatten(xs)
        = xs.reduce([], concat);

    
*/
// definition type (Func T0 R)
function flatten(// definition type T0
xs)
// expression type Error
// expression type (Func (Array $4) T1 T2 T1)
reduce(// expression type T0
xs, // expression type (Array $1507)
[], // expression type (Func T0 T1 R)
concat)// definition type (Func T0 T1 R)

/**
function flatMap(xs, f)       
        = xs.map(f).flatten;

*/
// definition type (Func T0 T1 R)
function flatMap(// definition type T0
xs, // definition type T1
f)
// expression type Error
// expression type (Func T0 R)
flatten(// expression type Error
// expression type (Func T0 T1 R)
map(// expression type T0
xs, // expression type T1
f))}

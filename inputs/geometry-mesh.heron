language heron:std:0.1;

module heron:geometry.mesh:0.1
{
    function mesh(vertices) 
        = mesh(vertices, vertices.indices);
    
    function mesh(vertices, indices) 
        = mesh(vertices, indices, origin.repeat(0), origin.repeat(0));

    function mesh(vertices, indices, colors, uvs)
        = { vertices=vertices, indices=indices, colors=colors, uvs=uvs };

    var tetrahedron 
        = mesh([1, 1, 1,   -1, -1, 1,   -1, 1, -1,   1, -1, -1], 
	           [2, 1, 0,    0, 3, 2,	1, 3, 0,	 2, 3, 1]);

    // Converts from UV coordinates to a float3
    function vector(uv: Float2)
        = float3(-uv.x.cos * uv.y.sin, uv.x.cos, uv.x.sin * uv.y.sin);
    
    // Works for Float, Float2, Float3, and Float4
    function rescale(v, from, length)
        = from + (v * length);

    /* TODO: finish this. 
    function quadStripToMesh(vertices, rows)
        = vertices.indices.
    */

    /*
    function sphere(radius, widthSegments, heightSegment, phiStart, phiLength, thetaStart, thetaLength) {
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        // generate vertices, normals and uvs

        for ( var iy in 0 .. heightSegments ) 
        {
            var verticesRow = [];
            var v = iy / heightSegments;

            for ( var ix in 0 .. widthSegments ) {

                var u = ix / widthSegments;

                // vertex

                var vtx = vector(x, y, z);
                vertices.push(vtx);

                // normal
                var normal = vector(x, y, z).normalize;
                normals.push(normal);

                // uv
                var uv = vector(u, 1 - v, 0);
                uvs.push(uv);
                verticesRow.push( index ++ );
            }

            grid.push( verticesRow );
        }

        // indices
        for ( var iy in 0 .. heightSegments ) {
            for ( var ix in 0 .. widthSegments ) {
                var a = grid[ iy ][ ix + 1 ];
                var b = grid[ iy ][ ix ];
                var c = grid[ iy + 1 ][ ix ];
                var d = grid[ iy + 1 ][ ix + 1 ];
                if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
                if ( iy !== heightSegments - 1 || thetaEnd < PI ) indices.push( b, c, d );
            }        
        }
    }
    */
}   

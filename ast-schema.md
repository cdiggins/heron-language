# Heron AST Schema

This document contains the formal description of the abstract syntax tree (AST) created when parsing Heron with Myna. 

```
additiveExpr <- seq(prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity])
additiveExprRight <- seq(additiveOp,prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity])
additiveOp <- additiveOp
arrayExpr <- seq(expr,expr[0,Infinity])[0,1]
arrayIndex <- expr
assignmentExpr <- seq(prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity],logicalAndExprRight[0,Infinity],logicalXOrExprRight[0,Infinity],logicalOrExprRight[0,Infinity],rangeExprRight[0,1],conditionalExprRight[0,Infinity],assignmentExprRight[0,Infinity])
assignmentExprRight <- seq(assignmentOp,prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity],logicalAndExprRight[0,Infinity],logicalXOrExprRight[0,Infinity],logicalOrExprRight[0,Infinity],rangeExprRight[0,1],conditionalExprRight[0,Infinity])
assignmentOp <- assignmentOp
bool <- bool
breakStatement <- breakStatement
compoundStatement <- recStatement[0,Infinity]
conditionalExpr <- seq(prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity],logicalAndExprRight[0,Infinity],logicalXOrExprRight[0,Infinity],logicalOrExprRight[0,Infinity],rangeExprRight[0,1],conditionalExprRight[0,Infinity])
conditionalExprRight <- seq(prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity],logicalAndExprRight[0,Infinity],logicalXOrExprRight[0,Infinity],logicalOrExprRight[0,Infinity],rangeExprRight[0,1],prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity],logicalAndExprRight[0,Infinity],logicalXOrExprRight[0,Infinity],logicalOrExprRight[0,Infinity],rangeExprRight[0,1])
continueStatement <- continueStatement
doLoop <- seq(recStatement,loopCond)
doubleQuotedStringContents <- stringLiteralChar[0,Infinity]
elseStatement <- recStatement
emptyStatement <- emptyStatement
equalityExpr <- seq(prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity])
equalityExprRight <- seq(equalityOp,prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity])
equalityOp <- equalityOp
exprStatement <- expr
fieldSelect <- identifier
file <- seq(langDecl[0,1],moduleName,moduleBody)
forLoop <- seq(identifier,expr,recStatement)
funCall <- seq(expr,expr[0,Infinity])[0,1]
funcBody <- choice(funcBodyStatement,funcBodyExpr)
funcBodyExpr <- expr
funcBodyStatement <- funcBodyStatement
funcDef <- seq(funcName,funcParams,funcBody)
funcName <- opName
funcParam <- seq(funcParamName,funcParamType[0,1])
funcParamName <- opName
funcParamType <- typeExpr
funcParams <- seq(funcParam,funcParam[0,Infinity])[0,1]
identifier <- opName
ifCond <- expr
ifStatement <- seq(ifCond,recStatement,elseStatement[0,Infinity])
lambdaArg <- seq(identifier,funcParamType[0,1])
lambdaArgs <- choice(lambdaArgsNoParen,lambdaArgsWithParen)
lambdaArgsNoParen <- opName
lambdaArgsWithParen <- seq(lambdaArg,lambdaArg[0,Infinity])[0,1]
lambdaBody <- choice(recCompoundStatement,expr)
lambdaExpr <- seq(lambdaArgs,lambdaBody)
langDecl <- langVer
langVer <- seq(urnPart,urnPart[0,Infinity])
logicalAndExpr <- seq(prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity],logicalAndExprRight[0,Infinity])
logicalAndExprRight <- seq(logicalAndOp,prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity])
logicalAndOp <- logicalAndOp
logicalOrExpr <- seq(prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity],logicalAndExprRight[0,Infinity],logicalXOrExprRight[0,Infinity],logicalOrExprRight[0,Infinity])
logicalOrExprRight <- seq(logicalOrOp,prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity],logicalAndExprRight[0,Infinity],logicalXOrExprRight[0,Infinity])
logicalOrOp <- logicalOrOp
logicalXOrExpr <- seq(prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity],logicalAndExprRight[0,Infinity],logicalXOrExprRight[0,Infinity])
logicalXOrExprRight <- seq(logicalXOrOp,prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity],logicalAndExprRight[0,Infinity])
logicalXOrOp <- logicalXOrOp
loopCond <- expr
moduleBody <- statement[0,Infinity]
moduleName <- seq(urnPart,urnPart[0,Infinity])
multiplicativeExpr <- seq(prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity])
multiplicativeExprRight <- seq(multiplicativeOp,prefixOp[0,Infinity],postfixExpr)
multiplicativeOp <- multiplicativeOp
number <- number
objectExpr <- objectField[0,Infinity]
objectField <- seq(identifier,expr)
opName <- opName
parenExpr <- expr
postDecOp <- postDecOp
postIncOp <- postIncOp
postfixExpr <- seq(choice(varExpr,objectExpr,lambdaExpr,parenExpr,arrayExpr,number,bool,string,identifier),choice(funCall,arrayIndex,fieldSelect,postIncOp,postDecOp)[0,Infinity])
prefixExpr <- seq(prefixOp[0,Infinity],postfixExpr)
prefixOp <- prefixOp
rangeExpr <- seq(prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity],logicalAndExprRight[0,Infinity],logicalXOrExprRight[0,Infinity],logicalOrExprRight[0,Infinity],rangeExprRight[0,1])
rangeExprRight <- seq(prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity],equalityExprRight[0,Infinity],logicalAndExprRight[0,Infinity],logicalXOrExprRight[0,Infinity],logicalOrExprRight[0,Infinity])
recCompoundStatement <- recCompoundStatement
relationalExpr <- seq(prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity],relationalExprRight[0,Infinity])
relationalExprRight <- seq(relationalOp,prefixOp[0,Infinity],postfixExpr,multiplicativeExprRight[0,Infinity],additiveExprRight[0,Infinity])
relationalOp <- relationalOp
returnStatement <- expr[0,1]
singleQuotedStringContents <- stringLiteralChar[0,Infinity]
statement <- choice(emptyStatement,compoundStatement,ifStatement,returnStatement,continueStatement,breakStatement,forLoop,doLoop,whileLoop,varDeclStatement,funcDef,exprStatement)
string <- choice(doubleQuotedStringContents,singleQuotedStringContents)
stringLiteralChar <- stringLiteralChar
typeExpr <- seq(typeName,typeParamList[0,1])
typeName <- opName
typeParam <- typeParam
typeParamList <- seq(typeParam,typeParam[0,Infinity])[0,1]
urn <- seq(urnPart,urnPart[0,Infinity])
urnPart <- urnPart
varDecl <- seq(varNameDecl,varInitialization)
varDeclStatement <- varDecls
varDecls <- seq(varDecl,varDecl[0,Infinity])
varExpr <- seq(varDecls,expr)
varInitialization <- expr
varNameDecl <- opName
whileLoop <- seq(loopCond,recStatement)
```